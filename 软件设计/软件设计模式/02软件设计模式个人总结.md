- ### 软件设计模式个人总结
    1. **模式的代码方式都十分相似，大多数基于组合模式**
    2. **模式是用于解决问题，或用于讨论方案**
    3. **设计模式核心是解决某种类型问题的思路，而不是具体的代码配方**


- ### 参考网站：
    1. [菜鸟](https://www.runoob.com/design-pattern/facade-pattern.html)
    2. [廖雪峰](https://www.liaoxuefeng.com/wiki/1252599548343744/1281319346634785)
    3. [refactoringguru](https://refactoringguru.cn/design-patterns/facade)


- #### 分类
    1. 创建型模式，**关注对象的创建**
    2. 结构型模式，**关注代码(类)的结构与组装**
    3. 行为模式，**关注对象之间调用方式**，在代码结构上部份与结构型模式类似



- #### 创建型模式
  1. **工厂模式（Factory Pattern）**
     1. 工厂类创建同一类型的对象
     2. 大多数情况下我们并不需要抽象工厂，而是通过静态方法直接返回对象
  2. 抽象工厂模式（Abstract Factory Pattern）
     1. 跟工厂模式类似，只是管理的对象是工厂本身
     2. 工厂-->工厂实现类-->产品
  3. **单例模式（Singleton Pattern）**
     1. 常用一：类加载时就初始化，但可能会浪费小小的内存
     2. 常用二：静态内部类
  4. 建造者模式 （生成器模式）（Builder Pattern）
     1. 通过Builder来确定构建对象所需的**模块和参数**，最后由Director来确认初始化的顺序
     2. 一般情况：Builder为创建对象的**内部类**，Director为Builder的一个**方法**
  5. 原型模式（Prototype Pattern）
     1. 当直接创建对象的代价比较大时，可以通过克隆原有对象
  
- #### 结构型模式
  1. 适配器模式（Adapter Pattern）
     1. 类：**组合封装**目标接口，**继承**原有接口
     2. 简单说：**接口的封装和别一个接口的调用**
  2. 桥接模式（Bridge Pattern）
     1. 组合封装所**依赖对象**的接口或着抽象类，**实现类由外部传入**，类似控制反转
     2. 多种依赖，每种依赖多种实现，能组装出更多不同功能的实现类
     3. 简单说：**不要接口依赖实现类，而是依赖接口**
  3. 组合模式（Composite Pattern）
     1. **树状结构**的组合
     2. 根节点、子节点的组合,xml,html等
  4. 装饰器模式（Decorator Pattern）
     1. 组合封装已有的实现类，**增强或减弱已有的功能**
  5. 外观模式（Facade Pattern）
     1. 内部实现复杂的调用流程，减少外部调用接口的复杂性
     2. 简单说：**给别人用的接口要简单，复杂的过程由内部实现**
  6. 享元模式（Flyweight Pattern）
     1. 目的：减少内存占用，减少反复创建相同的实例或数据
     2. **提取对象相同的部分**
     3. 方法一：通过依赖注入，指向同一引用
     4. 方法二：缓存在缓存池中，用到的时候再获取
     5. 简单说：**大量重复的数据，就缓存起来**
  7. 代理模式（Proxy Pattern）
     1. 中间代理类，代理执行请求
     2. 常用一：**静态代理**跟装饰器模式类似，增强已有的功能，并且代理执行。
     3. 常用二：**JDK动态代理**
     4. 常用三：**CGLIB动态代理**
     5. 有接口用JDK代理，无接口用CGLIB代理
     6. 简单说：**无非想在方法的调用前后加点代码**
  
- ### 行为型模式（动作模式、事务模式）
  1. 责任链模式（Chain of Responsibility Pattern）
     1. 每个对象都保存下一个处理对象（树状结构模式，从子节点到根节点的顺序）
     2. List<接口> for执行（单链模式，用得多）
     3. 简单说：**无非是，我处理不了，就下一个处理**
  2. 命令模式（Command Pattern）
     1. 组合封装对象中的方法，增强或增加方法中的其它功能，例如方法是复制数据的功能，命令模式中能增加撤消的功能
     2. 类似代理模式，但颗粒的更小，代理模式以整个对象的增强，而命令模式是**增强对象中的一个方法**
     3. 封装类一般为接口，可以传递出去，按顺序执行。如果通过List<封装类>记录执行过的命令，可以实现回退的功能。
     4. 简单说：**增强对象中的一个方法的功能**
  3. 解释器模式（Interpreter Pattern）
     1. 定义语法树的执行规则
     2. 表达式解释为语法树
     3. 简单说：**这玩意不简单，可以复杂得很**
  4. 迭代器模式（Iterator Pattern）
     1. 遍历集合，当内部数据的结构复杂时，可以使用，如内部数据为**数状结构**,减少外部调用的复杂度
     2. 方法一：实现类似List集合的Iterator 接口，自定义也是可以的。
     3. 方法二：实现类似**forEach**的方法，这种方法更好，外部代码更小。java中可以使用**lambda**表达式
     4. 简单说：**遍历数据而已，大多数情况爱咋搞咋搞**
  5. 中介者模式（Mediator Pattern）
     1. 多个对象之间的调用错综复杂；一个对象的状态改变，需要通知多个对象。中介类就是用于做各个对象的通知的。**单个对象中，不需要知道其它对象的存在**
     2. 简单说：**对象中相互通知，太麻烦了，需要个跑腿的**
  6. 备忘录模式（Memento Pattern）
     1. 简单的备忘录：针对某种类型的备忘录管理类，被备份的类需要实现状态获取，状态的恢复的接口
     2. 通用备忘录：针对中间类型的备忘录管理类，中间类可以保存各种类型。其它同上
     3. 简单说：**还没遇到过需要用到备忘录模式哇**
  7. 观察者模式(发布-订阅模式)（Observer Pattern）
     1. 注册中心类（记录接口，调用接口），订阅者（实现接口），发布者（发布消息）
     2. 一对多的依赖关系
     3. 简单说：**EventBus的实现**
  8. 状态模式（State Pattern）
     1. 减少因为状态不同而用庞大if...else...分支
     2. 一个状态是一个对象，对象内部是集合当前状态的各种处理逻辑
     3. 一般来说还需要一个状态管理器，用于切换状态
     4. 简单说：**状态就是对象，尽量少用if else**
  9. 策略模式（Strategy Pattern）
     1. 把经常变化的部分变成一个接口的调用，通过不同的实现类，实现不同的功能，或着得出不同的结果
     2. 与桥接模式类似，但更注重其中一个接口
     3. 简单说：**就是传接口实现类**
  10. 模板模式（Template Pattern）
      1. 抽象类提前固化要执行的顺序或都功能，少量的实现由继承类实现
      2. **一般情况不建议使用，可以通过传入接口实现类的方式实现**
  11. 访问者模式（Visitor Pattern）
      1. 简单说：**就是简单的接口回调**